def josephsring(n,k):
    '''
    约瑟夫环
    n个人围成一圈，从0开始编码。
    从第一个人（0号）开始计数，杀死第k个人，然后从下一个人开始计数，问谁能活到最后？
    输入：
    n：人数
    k：杀死第k个人
    返回：
    ans：活到最后的那个人
    '''
    #分析：
    #如果只有一个人，那直接返回0就可以了
    #如果是两个人，如果k是奇数，那0号先挂；如果是偶数，1号先挂
    #（这个时候我们发现k对n的余数(k-1)%n就是第一个挂掉的人，是否可以考虑递归？）
    #（等等……如果第i个人挂掉了，就会从i+1开始计数，可是我们的题目要求是从第一个人开始计数啊）
    #（如果递归的话，如果将从第i+1开始计数的问题转化为从第一个人开始计数的问题呢？）
    #（因为是一个环，假如从第1个人开始计数的结果是ans）
    #（将ans做一个魔法处理:(ans+i+1)%n是不是就得到从第i+1开始计数的结果了？）
    #（不对……还有一个问题：因为在n个人中，第i个人已经挂掉了，编号不再连续，变成了……,i-1,i+1,……）
    #（那么计算出的n-1个人的结果，怎样才能映射到这个不连续的序列上呢？）
    # 假设n=6,k=4
    # 原序列是：0 1 2 3 4 5
    # 计算第一个挂掉的人：i = (k-1)%n = (4-1)%6 = 3
    # 序列变成了A：0 1 2 4 5(下一个人从i+1=4开始计数)
    # 假如最终结果是ans
    # 由于需要递归，我们考虑n1=n-1=5,k=4的情形：
    # 原序列是A1：0 1 2 3 4
    # 假如最终活下来的人是ans1
    # 我们需要通过ans1来计算ans
    # 建立ans1到ans的映射：
    # 0 -> 4
    # 1 -> 5
    # 2 -> 0
    # 3 -> 1
    # 4 -> 2
    # 尝试用公式来描述这个映射:
    # ans = (ans1 + i)%n1
    # 映射为：
    # 0 -> 3（少了1）
    # 1 -> 4（少了1）
    # 2 -> 0
    # 3 -> 1
    # 4 -> 2
    # 调整为：
    # ans = (ans1 + i)%n1
    # if ans >= i:
    #     ans += 1
    if n == 1: return 0
    i = (k-1)%n
    ans1 = josephsring(n-1,k)
    ans = (ans1+i) % (n-1)
    if ans >= i:
        ans += 1
    return ans

if __name__ == '__main__':
    n,k = map(int,input().split())
    ans = josephsring(n,k)
    print(ans)