#经典的约瑟夫环问题，不容错过
#by leetcode.cn/u/ak-bot
#2022-5-4

def josephsring_recursive(n,k):
    '''
    约瑟夫环(递归解法)
    时间复杂度:O(n)
    n个人围成一圈，从0开始编码。
    从第一个人（0号）开始计数，杀死第k个人，然后从下一个人开始计数，问谁能活到最后？
    输入：
    n：人数
    k：杀死第k个人
    返回：
    ans：活到最后的那个人
    '''
    #分析：
    #如果只有一个人，那直接返回0就可以了
    #如果是两个人，如果k是奇数，那0号先挂；如果是偶数，1号先挂
    #（这个时候我们发现k-1对n的余数(k-1)%n就是第一个挂掉的人，是否可以考虑递归？）
    #（等等……如果第i个人挂掉了，就会从i+1开始计数，可是我们的题目要求是从第一个人开始计数啊）
    #（如果递归的话，如果将从第i+1开始计数的问题转化为从第一个人开始计数的问题呢？）
    #（因为是一个环，假如从第1个人开始计数的结果是ans）
    #（将ans做一个魔法处理:(ans+i+1)%n是不是就得到从第i+1开始计数的结果了？）
    #（不对……还有一个问题：因为在n个人中，第i个人已经挂掉了，编号不再连续，变成了……,i-1,i+1,……）
    #（那么计算出的n-1个人的结果，怎样才能映射到这个不连续的序列上呢？）
    # 假设n=6,k=4
    # 原序列是：0 1 2 3 4 5
    # 计算第一个挂掉的人：i = (k-1)%n = (4-1)%6 = 3
    # 序列变成了A：0 1 2 4 5(下一个人从i+1=4开始计数)
    # 假如最终结果是ans
    # 由于需要递归，我们考虑n1=n-1=5,k=4的情形：
    # 原序列是A1：0 1 2 3 4
    # 假如最终活下来的人是ans1
    # 我们需要通过ans1来计算ans
    # 建立ans1到ans的映射：
    # 0 -> 4
    # 1 -> 5
    # 2 -> 0
    # 3 -> 1
    # 4 -> 2
    # 尝试用公式来描述这个映射:
    # ans = (ans1 + i)%n1
    # 映射为：
    # 0 -> 3（少了1）
    # 1 -> 4（少了1）
    # 2 -> 0
    # 3 -> 1
    # 4 -> 2
    # 调整为：
    # ans = (ans1 + i)%n1
    # if ans >= i:
    #     ans += 1
    if n == 1: return 0
    i = (k-1)%n
    ans1 = josephsring_recursive(n-1,k)
    ans = (ans1+i) % (n-1)
    if ans >= i:
        ans += 1
    return ans

def josephsring_non_recursive(n,k):
    '''
    约瑟夫环(非递归解法)
    由于递归解法可能会栈溢出
    考虑非递归的解法
    '''
    #分析：
    #按照经验，递归解法应该都能转化为非递归
    #在递归的过程中n逐渐缩小为1，计算出n=1的结果后，再推广到n=2的值，逐渐放大直到计算出最后的结果
    #（等等，这个不就是动态规划么？）
    #删除递归中，缩小n到1的过程，直接以1为起点来计算结果，不断推广到下一个结果
    ans = 0
    for n1 in range(2,n+1):
        i = (k-1)%n1
        ans = (ans+i) % (n1-1)
        if ans >= i:
            ans += 1
    return ans

if __name__ == '__main__':
    n,k = map(int,input().split())
    #ans = josephsring_recursive(n,k)
    #print(ans)
    ans = josephsring_non_recursive(n,k)
    print(ans)